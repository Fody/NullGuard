.class public auto ansi beforefieldinit SimpleClass
       extends [mscorlib]System.Object
{
  .field private string '<NonNullProperty>k__BackingField'
  .field private string '<NullProperty>k__BackingField'
  .field private string '<PropertyAllowsNullGetButDoesNotAllowNullSet>k__BackingField'
  .field private string '<PropertyAllowsNullSetButDoesNotAllowNullGet>k__BackingField'
  .field private valuetype [mscorlib]System.Nullable`1<int32> '<NonNullNullableProperty>k__BackingField'
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  1
    .language '{3F5162F8-07C6-11D3-9053-00C04FA302A1}', '{994B45C4-E6E9-11D2-903F-00C04FA302A1}', '{5A869D0B-6611-11D3-BD2A-0000F80849BD}'
//000006:     public SimpleClass()
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ret
  } 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor([out] string& nonNullOutArg) cil managed
  {
    // Code size       25 (0x19)
    .maxstack  2
//000007:     {
//000008:     }
//000009: 
//000010:     // Why would anyone place an out parameter on a ctor?! I don't know, but I'll support your idiocy.
//000011:     public SimpleClass(out string nonNullOutArg)
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
//000012:     {
//000013:         nonNullOutArg = null;
    IL_0006:  ldarg.1
    IL_0007:  ldnull
    IL_0008:  stind.ref
//000014:     }
//000015: 
//000016:     public SimpleClass(string nonNullArg, [AllowNull] string nullArg)
//000017:     {
//000018:         Console.WriteLine(nonNullArg + " " + nullArg);
//000019:     }
//000020: 
//000021:     public void SomeMethod(string nonNullArg, [AllowNull] string nullArg)
//000022:     {
//000023:         Console.WriteLine(nonNullArg);
//000024:     }
//000025: 
//000026:     public string NonNullProperty { get; set; }
//000027: 
//000028:     [AllowNull]
//000029:     public string NullProperty { get; set; }
//000030: 
//000031:     public string PropertyAllowsNullGetButDoesNotAllowNullSet { [return: AllowNull] get; set; }
//000032: 
//000033:     public string PropertyAllowsNullSetButDoesNotAllowNullGet { get; [param: AllowNull] set; }
//000034: 
//000035:     public int? NonNullNullableProperty { get; set; }
//000036: 
//000037:     public string MethodWithReturnValue(bool returnNull)
//000038:     {
//000039:         return returnNull ? null : "";
//000040:     }
//000041: 
//000042:     public void MethodWithRef(ref object returnNull)
//000043:     {
//000044:     }
//000045: 
//000046:     public void MethodWithGeneric<T>(T returnNull)
//000047:     {
//000048:     }
//000049: 
//000050:     public void MethodWithGenericRef<T>(ref T returnNull)
//000051:     {
//000052:     }
//000053: 
//000054:     [return: AllowNull]
//000055:     public string MethodAllowsNullReturnValue()
//000056:     {
//000057:         return null;
//000058:     }
//000059: 
//000060:     [CanBeNull]
//000061:     public string MethodWithCanBeNullResult()
//000062:     {
//000063:         return null;
//000064:     }
//000065: 
//000066:     public void MethodWithOutValue(out string nonNullOutArg)
//000067:     {
//000068:         nonNullOutArg = null;
//000069:     }
//000070: 
//000071:     public void MethodWithAllowedNullOutValue([AllowNull]out string nonNullOutArg)
//000072:     {
//000073:         nonNullOutArg = null;
//000074:     }
//000075: 
//000076:     public void PublicWrapperOfPrivateMethod()
//000077:     {
//000078:         SomePrivateMethod(null);
//000079:     }
//000080: 
//000081:     void SomePrivateMethod(string x)
//000082:     {
//000083:         Console.WriteLine(x);
//000084:     }
//000085: 
//000086:     public void MethodWithTwoRefs(ref string first, ref string second)
//000087:     {
//000088:     }
//000089: 
//000090:     public void MethodWithTwoOuts(out string first, out string second)
//000091:     {
//000092:         first = null;
//000093:         second = null;
//000094:     }
//000095: 
//000096:     public void MethodWithOptionalParameter(string optional = null)
//000097:     {
//000098:     }
//000099: 
//000100:     public void MethodWithOptionalParameterWithNonNullDefaultValue(string optional = "default")
//000101:     {
//000102:     }
//000103: 
//000104:     public void MethodWithOptionalParameterWithNonNullDefaultValueButAllowNullAttribute([AllowNull] string optional = "default")
//000105:     {
//000106:     }
//000107: 
//000108:     public void MethodWithGenericOut<T>(out T item)
//000109:     {
//000110:         item = default;
//000111:     }
//000112: 
//000113:     public T MethodWithGenericReturn<T>(bool returnNull)
//000114:     {
//000115:         return returnNull ? default : Activator.CreateInstance<T>();
//000116:     }
//000117: 
//000118:     public object MethodWithOutAndReturn(out string prefix)
//000119:     {
//000120:         prefix = null;
//000121:         return null;
//000122:     }
//000123: 
//000124:     public void MethodWithExistingArgumentGuard(string x)
//000125:     {
//000126:         if (string.IsNullOrEmpty(x))
//000127:             throw new ArgumentException("x is null or empty.", "x");
//000128: 
//000129:         Console.WriteLine(x);
//000130:     }
//000131: 
//000132:     public void MethodWithExistingArgumentNullGuard(string x)
//000133:     {
//000134:         if (string.IsNullOrEmpty(x))
//000135:             throw new ArgumentNullException("x");
//000136: 
//000137:         Console.WriteLine(x);
//000138:     }
//000139: 
//000140:     public void MethodWithExistingArgumentNullGuardWithMessage(string x)
//000141:     {
//000142:         if (string.IsNullOrEmpty(x))
//000143:             throw new ArgumentNullException("x", "x is null or empty.");
//000144: 
//000145:         Console.WriteLine(x);
//000146:     }
//000147: 
//000148:     public string ReturnValueChecksWithBranchToRetInstruction()
//000149:     {
//000150:         // This is a regression test scenario for the "Branch to RET" issue described in https://github.com/Fody/NullGuard/issues/57.
//000151: 
//000152:         // It is important that the return value is assigned *before* the branch, otherwise the C# compiler emits
//000153:         // instructions before the RET instructions, which wouldn't trigger the original issue.
//000154:         string returnValue = null;
//000155: 
//000156:         // The following, not-reachable, branch will jump directly to the RET statement (at least with Roslyn 1.0 with
//000157:         // enabled optimizations flag) which triggers the issue (the return value checks will be skipped).
//000158:         if ("".Length == 42)
//000159:             throw new Exception("Not reachable");
//000160: 
//000161:         return returnValue;
//000162:     }
//000163: 
//000164:     public void OutValueChecksWithBranchToRetInstruction(out string outParam)
//000165:     {
//000166:         // This is the same scenario as above, but for out parameters.
//000167: 
//000168:         outParam = null;
//000169: 
//000170:         if ("".Length == 42)
//000171:             throw new Exception("Not reachable");
//000172:     }
//000173: 
//000174:     public string GetterReturnValueChecksWithBranchToRetInstruction
//000175:     {
//000176:         get
//000177:         {
//000178:             // This is the same scenario as above, but for property getters.
//000179: 
//000180:             string returnValue = null;
//000181: 
//000182:             if ("".Length == 42)
//000183:                 throw new Exception("Not reachable");
//000184: 
//000185:             return returnValue;
//000186:         }
//000187:     }
//000188: 
//000189:     public void OutValueChecksWithRetInstructionAsSwitchCase(int i, out string outParam)
//000190:     {
//000191:         // This is the same scenario as above, but with a SWITCH instruction with branch targets to RET
//000192:         // instructions (they are handled specially).
//000193:         // Note that its important to have more than sections to prove that all sections with only a RET instruction are handled.
//000194: 
//000195:         outParam = null;
//000196:         switch (i)
//000197:         {
//000198:             case 0:
//000199:                 return;
//000200:             case 1:
//000201:                 Console.WriteLine("1");
//000202:                 break;
//000203:             case 2:
//000204:                 return;
//000205:             case 3:
//000206:                 Console.WriteLine("3");
//000207:                 break;
//000208:         }
//000209:     }
//000210: }
    IL_0009:  ldarg.1
    IL_000a:  ldind.ref
    IL_000b:  brtrue.s   IL_0018
    IL_000d:  ldstr      "[NullGuard] Out parameter 'nonNullOutArg' is null."
    IL_0012:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_0017:  throw
    IL_0018:  ret
  } 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(string nonNullArg,
                               string nullArg) cil managed
  {
    // Code size       43 (0x2b)
    .maxstack  3
    IL_0000:  ldarg.1
    IL_0001:  brtrue.s   IL_0013
    IL_0003:  ldstr      "nonNullArg"
    IL_0008:  ldstr      "[NullGuard] nonNullArg is null."
    IL_000d:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string,
                                                                                     string)
    IL_0012:  throw
//000016:     public SimpleClass(string nonNullArg, [AllowNull] string nullArg)
    IL_0013:  ldarg.0
    IL_0014:  call       instance void [mscorlib]System.Object::.ctor()
//000017:     {
//000018:         Console.WriteLine(nonNullArg + " " + nullArg);
    IL_0019:  ldarg.1
    IL_001a:  ldstr      " "
    IL_001f:  ldarg.2
    IL_0020:  call       string [mscorlib]System.String::Concat(string,
                                                                string,
                                                                string)
    IL_0025:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_002a:  ret
  } 
  .method public hidebysig instance void 
          SomeMethod(string nonNullArg,
                     string nullArg) cil managed
  {
    // Code size       26 (0x1a)
    .maxstack  2
//000019:     }
//000020: 
//000021:     public void SomeMethod(string nonNullArg, [AllowNull] string nullArg)
//000022:     {
//000023:         Console.WriteLine(nonNullArg);
//000024:     }
//000025: 
//000026:     public string NonNullProperty { get; set; }
//000027: 
//000028:     [AllowNull]
//000029:     public string NullProperty { get; set; }
//000030: 
//000031:     public string PropertyAllowsNullGetButDoesNotAllowNullSet { [return: AllowNull] get; set; }
//000032: 
//000033:     public string PropertyAllowsNullSetButDoesNotAllowNullGet { get; [param: AllowNull] set; }
//000034: 
//000035:     public int? NonNullNullableProperty { get; set; }
//000036: 
//000037:     public string MethodWithReturnValue(bool returnNull)
//000038:     {
//000039:         return returnNull ? null : "";
//000040:     }
//000041: 
//000042:     public void MethodWithRef(ref object returnNull)
//000043:     {
//000044:     }
//000045: 
//000046:     public void MethodWithGeneric<T>(T returnNull)
//000047:     {
//000048:     }
//000049: 
//000050:     public void MethodWithGenericRef<T>(ref T returnNull)
//000051:     {
//000052:     }
//000053: 
//000054:     [return: AllowNull]
//000055:     public string MethodAllowsNullReturnValue()
//000056:     {
//000057:         return null;
//000058:     }
//000059: 
//000060:     [CanBeNull]
//000061:     public string MethodWithCanBeNullResult()
//000062:     {
//000063:         return null;
//000064:     }
//000065: 
//000066:     public void MethodWithOutValue(out string nonNullOutArg)
//000067:     {
//000068:         nonNullOutArg = null;
//000069:     }
//000070: 
//000071:     public void MethodWithAllowedNullOutValue([AllowNull]out string nonNullOutArg)
//000072:     {
//000073:         nonNullOutArg = null;
//000074:     }
//000075: 
//000076:     public void PublicWrapperOfPrivateMethod()
//000077:     {
//000078:         SomePrivateMethod(null);
//000079:     }
//000080: 
//000081:     void SomePrivateMethod(string x)
//000082:     {
//000083:         Console.WriteLine(x);
//000084:     }
//000085: 
//000086:     public void MethodWithTwoRefs(ref string first, ref string second)
//000087:     {
//000088:     }
//000089: 
//000090:     public void MethodWithTwoOuts(out string first, out string second)
//000091:     {
//000092:         first = null;
//000093:         second = null;
//000094:     }
//000095: 
//000096:     public void MethodWithOptionalParameter(string optional = null)
//000097:     {
//000098:     }
//000099: 
//000100:     public void MethodWithOptionalParameterWithNonNullDefaultValue(string optional = "default")
//000101:     {
//000102:     }
//000103: 
//000104:     public void MethodWithOptionalParameterWithNonNullDefaultValueButAllowNullAttribute([AllowNull] string optional = "default")
//000105:     {
//000106:     }
//000107: 
//000108:     public void MethodWithGenericOut<T>(out T item)
//000109:     {
//000110:         item = default;
//000111:     }
//000112: 
//000113:     public T MethodWithGenericReturn<T>(bool returnNull)
//000114:     {
//000115:         return returnNull ? default : Activator.CreateInstance<T>();
//000116:     }
//000117: 
//000118:     public object MethodWithOutAndReturn(out string prefix)
//000119:     {
//000120:         prefix = null;
//000121:         return null;
//000122:     }
//000123: 
//000124:     public void MethodWithExistingArgumentGuard(string x)
//000125:     {
//000126:         if (string.IsNullOrEmpty(x))
//000127:             throw new ArgumentException("x is null or empty.", "x");
//000128: 
//000129:         Console.WriteLine(x);
//000130:     }
//000131: 
//000132:     public void MethodWithExistingArgumentNullGuard(string x)
//000133:     {
//000134:         if (string.IsNullOrEmpty(x))
//000135:             throw new ArgumentNullException("x");
//000136: 
//000137:         Console.WriteLine(x);
//000138:     }
//000139: 
//000140:     public void MethodWithExistingArgumentNullGuardWithMessage(string x)
//000141:     {
//000142:         if (string.IsNullOrEmpty(x))
//000143:             throw new ArgumentNullException("x", "x is null or empty.");
//000144: 
//000145:         Console.WriteLine(x);
//000146:     }
//000147: 
//000148:     public string ReturnValueChecksWithBranchToRetInstruction()
//000149:     {
//000150:         // This is a regression test scenario for the "Branch to RET" issue described in https://github.com/Fody/NullGuard/issues/57.
//000151: 
//000152:         // It is important that the return value is assigned *before* the branch, otherwise the C# compiler emits
//000153:         // instructions before the RET instructions, which wouldn't trigger the original issue.
//000154:         string returnValue = null;
//000155: 
//000156:         // The following, not-reachable, branch will jump directly to the RET statement (at least with Roslyn 1.0 with
//000157:         // enabled optimizations flag) which triggers the issue (the return value checks will be skipped).
//000158:         if ("".Length == 42)
//000159:             throw new Exception("Not reachable");
//000160: 
//000161:         return returnValue;
//000162:     }
//000163: 
//000164:     public void OutValueChecksWithBranchToRetInstruction(out string outParam)
//000165:     {
//000166:         // This is the same scenario as above, but for out parameters.
//000167: 
//000168:         outParam = null;
//000169: 
//000170:         if ("".Length == 42)
//000171:             throw new Exception("Not reachable");
//000172:     }
//000173: 
//000174:     public string GetterReturnValueChecksWithBranchToRetInstruction
//000175:     {
//000176:         get
//000177:         {
//000178:             // This is the same scenario as above, but for property getters.
//000179: 
//000180:             string returnValue = null;
//000181: 
//000182:             if ("".Length == 42)
//000183:                 throw new Exception("Not reachable");
//000184: 
//000185:             return returnValue;
//000186:         }
//000187:     }
//000188: 
//000189:     public void OutValueChecksWithRetInstructionAsSwitchCase(int i, out string outParam)
//000190:     {
//000191:         // This is the same scenario as above, but with a SWITCH instruction with branch targets to RET
//000192:         // instructions (they are handled specially).
//000193:         // Note that its important to have more than sections to prove that all sections with only a RET instruction are handled.
//000194: 
//000195:         outParam = null;
//000196:         switch (i)
//000197:         {
//000198:             case 0:
//000199:                 return;
//000200:             case 1:
//000201:                 Console.WriteLine("1");
//000202:                 break;
//000203:             case 2:
//000204:                 return;
//000205:             case 3:
//000206:                 Console.WriteLine("3");
//000207:                 break;
//000208:         }
//000209:     }
//000210: }
    IL_0000:  ldarg.1
    IL_0001:  brtrue.s   IL_0013
    IL_0003:  ldstr      "nonNullArg"
    IL_0008:  ldstr      "[NullGuard] nonNullArg is null."
    IL_000d:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string,
                                                                                     string)
    IL_0012:  throw
//000023:         Console.WriteLine(nonNullArg);
    IL_0013:  ldarg.1
    IL_0014:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_0019:  ret
  } 
  .method public hidebysig specialname instance string 
          get_NonNullProperty() cil managed
  {
    // Code size       22 (0x16)
    .maxstack  2
//000024:     }
//000025: 
//000026:     public string NonNullProperty { get; set; }
    IL_0000:  ldarg.0
    IL_0001:  ldfld      string SimpleClass::'<NonNullProperty>k__BackingField'
//000027: 
//000028:     [AllowNull]
//000029:     public string NullProperty { get; set; }
//000030: 
//000031:     public string PropertyAllowsNullGetButDoesNotAllowNullSet { [return: AllowNull] get; set; }
//000032: 
//000033:     public string PropertyAllowsNullSetButDoesNotAllowNullGet { get; [param: AllowNull] set; }
//000034: 
//000035:     public int? NonNullNullableProperty { get; set; }
//000036: 
//000037:     public string MethodWithReturnValue(bool returnNull)
//000038:     {
//000039:         return returnNull ? null : "";
//000040:     }
//000041: 
//000042:     public void MethodWithRef(ref object returnNull)
//000043:     {
//000044:     }
//000045: 
//000046:     public void MethodWithGeneric<T>(T returnNull)
//000047:     {
//000048:     }
//000049: 
//000050:     public void MethodWithGenericRef<T>(ref T returnNull)
//000051:     {
//000052:     }
//000053: 
//000054:     [return: AllowNull]
//000055:     public string MethodAllowsNullReturnValue()
//000056:     {
//000057:         return null;
//000058:     }
//000059: 
//000060:     [CanBeNull]
//000061:     public string MethodWithCanBeNullResult()
//000062:     {
//000063:         return null;
//000064:     }
//000065: 
//000066:     public void MethodWithOutValue(out string nonNullOutArg)
//000067:     {
//000068:         nonNullOutArg = null;
//000069:     }
//000070: 
//000071:     public void MethodWithAllowedNullOutValue([AllowNull]out string nonNullOutArg)
//000072:     {
//000073:         nonNullOutArg = null;
//000074:     }
//000075: 
//000076:     public void PublicWrapperOfPrivateMethod()
//000077:     {
//000078:         SomePrivateMethod(null);
//000079:     }
//000080: 
//000081:     void SomePrivateMethod(string x)
//000082:     {
//000083:         Console.WriteLine(x);
//000084:     }
//000085: 
//000086:     public void MethodWithTwoRefs(ref string first, ref string second)
//000087:     {
//000088:     }
//000089: 
//000090:     public void MethodWithTwoOuts(out string first, out string second)
//000091:     {
//000092:         first = null;
//000093:         second = null;
//000094:     }
//000095: 
//000096:     public void MethodWithOptionalParameter(string optional = null)
//000097:     {
//000098:     }
//000099: 
//000100:     public void MethodWithOptionalParameterWithNonNullDefaultValue(string optional = "default")
//000101:     {
//000102:     }
//000103: 
//000104:     public void MethodWithOptionalParameterWithNonNullDefaultValueButAllowNullAttribute([AllowNull] string optional = "default")
//000105:     {
//000106:     }
//000107: 
//000108:     public void MethodWithGenericOut<T>(out T item)
//000109:     {
//000110:         item = default;
//000111:     }
//000112: 
//000113:     public T MethodWithGenericReturn<T>(bool returnNull)
//000114:     {
//000115:         return returnNull ? default : Activator.CreateInstance<T>();
//000116:     }
//000117: 
//000118:     public object MethodWithOutAndReturn(out string prefix)
//000119:     {
//000120:         prefix = null;
//000121:         return null;
//000122:     }
//000123: 
//000124:     public void MethodWithExistingArgumentGuard(string x)
//000125:     {
//000126:         if (string.IsNullOrEmpty(x))
//000127:             throw new ArgumentException("x is null or empty.", "x");
//000128: 
//000129:         Console.WriteLine(x);
//000130:     }
//000131: 
//000132:     public void MethodWithExistingArgumentNullGuard(string x)
//000133:     {
//000134:         if (string.IsNullOrEmpty(x))
//000135:             throw new ArgumentNullException("x");
//000136: 
//000137:         Console.WriteLine(x);
//000138:     }
//000139: 
//000140:     public void MethodWithExistingArgumentNullGuardWithMessage(string x)
//000141:     {
//000142:         if (string.IsNullOrEmpty(x))
//000143:             throw new ArgumentNullException("x", "x is null or empty.");
//000144: 
//000145:         Console.WriteLine(x);
//000146:     }
//000147: 
//000148:     public string ReturnValueChecksWithBranchToRetInstruction()
//000149:     {
//000150:         // This is a regression test scenario for the "Branch to RET" issue described in https://github.com/Fody/NullGuard/issues/57.
//000151: 
//000152:         // It is important that the return value is assigned *before* the branch, otherwise the C# compiler emits
//000153:         // instructions before the RET instructions, which wouldn't trigger the original issue.
//000154:         string returnValue = null;
//000155: 
//000156:         // The following, not-reachable, branch will jump directly to the RET statement (at least with Roslyn 1.0 with
//000157:         // enabled optimizations flag) which triggers the issue (the return value checks will be skipped).
//000158:         if ("".Length == 42)
//000159:             throw new Exception("Not reachable");
//000160: 
//000161:         return returnValue;
//000162:     }
//000163: 
//000164:     public void OutValueChecksWithBranchToRetInstruction(out string outParam)
//000165:     {
//000166:         // This is the same scenario as above, but for out parameters.
//000167: 
//000168:         outParam = null;
//000169: 
//000170:         if ("".Length == 42)
//000171:             throw new Exception("Not reachable");
//000172:     }
//000173: 
//000174:     public string GetterReturnValueChecksWithBranchToRetInstruction
//000175:     {
//000176:         get
//000177:         {
//000178:             // This is the same scenario as above, but for property getters.
//000179: 
//000180:             string returnValue = null;
//000181: 
//000182:             if ("".Length == 42)
//000183:                 throw new Exception("Not reachable");
//000184: 
//000185:             return returnValue;
//000186:         }
//000187:     }
//000188: 
//000189:     public void OutValueChecksWithRetInstructionAsSwitchCase(int i, out string outParam)
//000190:     {
//000191:         // This is the same scenario as above, but with a SWITCH instruction with branch targets to RET
//000192:         // instructions (they are handled specially).
//000193:         // Note that its important to have more than sections to prove that all sections with only a RET instruction are handled.
//000194: 
//000195:         outParam = null;
//000196:         switch (i)
//000197:         {
//000198:             case 0:
//000199:                 return;
//000200:             case 1:
//000201:                 Console.WriteLine("1");
//000202:                 break;
//000203:             case 2:
//000204:                 return;
//000205:             case 3:
//000206:                 Console.WriteLine("3");
//000207:                 break;
//000208:         }
//000209:     }
//000210: }
    IL_0006:  dup
    IL_0007:  brtrue.s   IL_0015
    IL_0009:  pop
    IL_000a:  ldstr      "[NullGuard] Return value of property 'System.Strin"
    + "g SimpleClass::NonNullProperty()' is null."
    IL_000f:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_0014:  throw
    IL_0015:  ret
  } 
  .method public hidebysig specialname instance void 
          set_NonNullProperty(string 'value') cil managed
  {
    // Code size       27 (0x1b)
    .maxstack  2
    IL_0000:  ldarg.1
    IL_0001:  brtrue.s   IL_0013
    IL_0003:  ldstr      "value"
    IL_0008:  ldstr      "[NullGuard] Cannot set the value of property 'Syst"
    + "em.String SimpleClass::NonNullProperty()' to null."
    IL_000d:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string,
                                                                                     string)
    IL_0012:  throw
//000026:     public string NonNullProperty { get; set; }
    IL_0013:  ldarg.0
    IL_0014:  ldarg.1
    IL_0015:  stfld      string SimpleClass::'<NonNullProperty>k__BackingField'
    IL_001a:  ret
  } 
  .method public hidebysig specialname instance string 
          get_NullProperty() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
//000027: 
//000028:     [AllowNull]
//000029:     public string NullProperty { get; set; }
    IL_0000:  ldarg.0
    IL_0001:  ldfld      string SimpleClass::'<NullProperty>k__BackingField'
    IL_0006:  ret
  } 
  .method public hidebysig specialname instance void 
          set_NullProperty(string 'value') cil managed
  {
    // Code size       8 (0x8)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  ldarg.1
    IL_0002:  stfld      string SimpleClass::'<NullProperty>k__BackingField'
    IL_0007:  ret
  } 
  .method public hidebysig specialname instance string 
          get_PropertyAllowsNullGetButDoesNotAllowNullSet() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  1
//000030: 
//000031:     public string PropertyAllowsNullGetButDoesNotAllowNullSet { [return: AllowNull] get; set; }
    IL_0000:  ldarg.0
    IL_0001:  ldfld      string SimpleClass::'<PropertyAllowsNullGetButDoesNotAllowNullSet>k__BackingField'
    IL_0006:  ret
  } 
  .method public hidebysig specialname instance void 
          set_PropertyAllowsNullGetButDoesNotAllowNullSet(string 'value') cil managed
  {
    // Code size       27 (0x1b)
    .maxstack  2
//000032: 
//000033:     public string PropertyAllowsNullSetButDoesNotAllowNullGet { get; [param: AllowNull] set; }
//000034: 
//000035:     public int? NonNullNullableProperty { get; set; }
//000036: 
//000037:     public string MethodWithReturnValue(bool returnNull)
//000038:     {
//000039:         return returnNull ? null : "";
//000040:     }
//000041: 
//000042:     public void MethodWithRef(ref object returnNull)
//000043:     {
//000044:     }
//000045: 
//000046:     public void MethodWithGeneric<T>(T returnNull)
//000047:     {
//000048:     }
//000049: 
//000050:     public void MethodWithGenericRef<T>(ref T returnNull)
//000051:     {
//000052:     }
//000053: 
//000054:     [return: AllowNull]
//000055:     public string MethodAllowsNullReturnValue()
//000056:     {
//000057:         return null;
//000058:     }
//000059: 
//000060:     [CanBeNull]
//000061:     public string MethodWithCanBeNullResult()
//000062:     {
//000063:         return null;
//000064:     }
//000065: 
//000066:     public void MethodWithOutValue(out string nonNullOutArg)
//000067:     {
//000068:         nonNullOutArg = null;
//000069:     }
//000070: 
//000071:     public void MethodWithAllowedNullOutValue([AllowNull]out string nonNullOutArg)
//000072:     {
//000073:         nonNullOutArg = null;
//000074:     }
//000075: 
//000076:     public void PublicWrapperOfPrivateMethod()
//000077:     {
//000078:         SomePrivateMethod(null);
//000079:     }
//000080: 
//000081:     void SomePrivateMethod(string x)
//000082:     {
//000083:         Console.WriteLine(x);
//000084:     }
//000085: 
//000086:     public void MethodWithTwoRefs(ref string first, ref string second)
//000087:     {
//000088:     }
//000089: 
//000090:     public void MethodWithTwoOuts(out string first, out string second)
//000091:     {
//000092:         first = null;
//000093:         second = null;
//000094:     }
//000095: 
//000096:     public void MethodWithOptionalParameter(string optional = null)
//000097:     {
//000098:     }
//000099: 
//000100:     public void MethodWithOptionalParameterWithNonNullDefaultValue(string optional = "default")
//000101:     {
//000102:     }
//000103: 
//000104:     public void MethodWithOptionalParameterWithNonNullDefaultValueButAllowNullAttribute([AllowNull] string optional = "default")
//000105:     {
//000106:     }
//000107: 
//000108:     public void MethodWithGenericOut<T>(out T item)
//000109:     {
//000110:         item = default;
//000111:     }
//000112: 
//000113:     public T MethodWithGenericReturn<T>(bool returnNull)
//000114:     {
//000115:         return returnNull ? default : Activator.CreateInstance<T>();
//000116:     }
//000117: 
//000118:     public object MethodWithOutAndReturn(out string prefix)
//000119:     {
//000120:         prefix = null;
//000121:         return null;
//000122:     }
//000123: 
//000124:     public void MethodWithExistingArgumentGuard(string x)
//000125:     {
//000126:         if (string.IsNullOrEmpty(x))
//000127:             throw new ArgumentException("x is null or empty.", "x");
//000128: 
//000129:         Console.WriteLine(x);
//000130:     }
//000131: 
//000132:     public void MethodWithExistingArgumentNullGuard(string x)
//000133:     {
//000134:         if (string.IsNullOrEmpty(x))
//000135:             throw new ArgumentNullException("x");
//000136: 
//000137:         Console.WriteLine(x);
//000138:     }
//000139: 
//000140:     public void MethodWithExistingArgumentNullGuardWithMessage(string x)
//000141:     {
//000142:         if (string.IsNullOrEmpty(x))
//000143:             throw new ArgumentNullException("x", "x is null or empty.");
//000144: 
//000145:         Console.WriteLine(x);
//000146:     }
//000147: 
//000148:     public string ReturnValueChecksWithBranchToRetInstruction()
//000149:     {
//000150:         // This is a regression test scenario for the "Branch to RET" issue described in https://github.com/Fody/NullGuard/issues/57.
//000151: 
//000152:         // It is important that the return value is assigned *before* the branch, otherwise the C# compiler emits
//000153:         // instructions before the RET instructions, which wouldn't trigger the original issue.
//000154:         string returnValue = null;
//000155: 
//000156:         // The following, not-reachable, branch will jump directly to the RET statement (at least with Roslyn 1.0 with
//000157:         // enabled optimizations flag) which triggers the issue (the return value checks will be skipped).
//000158:         if ("".Length == 42)
//000159:             throw new Exception("Not reachable");
//000160: 
//000161:         return returnValue;
//000162:     }
//000163: 
//000164:     public void OutValueChecksWithBranchToRetInstruction(out string outParam)
//000165:     {
//000166:         // This is the same scenario as above, but for out parameters.
//000167: 
//000168:         outParam = null;
//000169: 
//000170:         if ("".Length == 42)
//000171:             throw new Exception("Not reachable");
//000172:     }
//000173: 
//000174:     public string GetterReturnValueChecksWithBranchToRetInstruction
//000175:     {
//000176:         get
//000177:         {
//000178:             // This is the same scenario as above, but for property getters.
//000179: 
//000180:             string returnValue = null;
//000181: 
//000182:             if ("".Length == 42)
//000183:                 throw new Exception("Not reachable");
//000184: 
//000185:             return returnValue;
//000186:         }
//000187:     }
//000188: 
//000189:     public void OutValueChecksWithRetInstructionAsSwitchCase(int i, out string outParam)
//000190:     {
//000191:         // This is the same scenario as above, but with a SWITCH instruction with branch targets to RET
//000192:         // instructions (they are handled specially).
//000193:         // Note that its important to have more than sections to prove that all sections with only a RET instruction are handled.
//000194: 
//000195:         outParam = null;
//000196:         switch (i)
//000197:         {
//000198:             case 0:
//000199:                 return;
//000200:             case 1:
//000201:                 Console.WriteLine("1");
//000202:                 break;
//000203:             case 2:
//000204:                 return;
//000205:             case 3:
//000206:                 Console.WriteLine("3");
//000207:                 break;
//000208:         }
//000209:     }
//000210: }
    IL_0000:  ldarg.1
    IL_0001:  brtrue.s   IL_0013
    IL_0003:  ldstr      "value"
    IL_0008:  ldstr      "[NullGuard] Cannot set the value of property 'Syst"
    + "em.String SimpleClass::PropertyAllowsNullGetButDoesNotAllowNullSet()' t"
    + "o null."
    IL_000d:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string,
                                                                                     string)
    IL_0012:  throw
//000031:     public string PropertyAllowsNullGetButDoesNotAllowNullSet { [return: AllowNull] get; set; }
    IL_0013:  ldarg.0
    IL_0014:  ldarg.1
    IL_0015:  stfld      string SimpleClass::'<PropertyAllowsNullGetButDoesNotAllowNullSet>k__BackingField'
    IL_001a:  ret
  } 
  .method public hidebysig specialname instance string 
          get_PropertyAllowsNullSetButDoesNotAllowNullGet() cil managed
  {
    // Code size       22 (0x16)
    .maxstack  2
//000032: 
//000033:     public string PropertyAllowsNullSetButDoesNotAllowNullGet { get; [param: AllowNull] set; }
    IL_0000:  ldarg.0
    IL_0001:  ldfld      string SimpleClass::'<PropertyAllowsNullSetButDoesNotAllowNullGet>k__BackingField'
//000034: 
//000035:     public int? NonNullNullableProperty { get; set; }
//000036: 
//000037:     public string MethodWithReturnValue(bool returnNull)
//000038:     {
//000039:         return returnNull ? null : "";
//000040:     }
//000041: 
//000042:     public void MethodWithRef(ref object returnNull)
//000043:     {
//000044:     }
//000045: 
//000046:     public void MethodWithGeneric<T>(T returnNull)
//000047:     {
//000048:     }
//000049: 
//000050:     public void MethodWithGenericRef<T>(ref T returnNull)
//000051:     {
//000052:     }
//000053: 
//000054:     [return: AllowNull]
//000055:     public string MethodAllowsNullReturnValue()
//000056:     {
//000057:         return null;
//000058:     }
//000059: 
//000060:     [CanBeNull]
//000061:     public string MethodWithCanBeNullResult()
//000062:     {
//000063:         return null;
//000064:     }
//000065: 
//000066:     public void MethodWithOutValue(out string nonNullOutArg)
//000067:     {
//000068:         nonNullOutArg = null;
//000069:     }
//000070: 
//000071:     public void MethodWithAllowedNullOutValue([AllowNull]out string nonNullOutArg)
//000072:     {
//000073:         nonNullOutArg = null;
//000074:     }
//000075: 
//000076:     public void PublicWrapperOfPrivateMethod()
//000077:     {
//000078:         SomePrivateMethod(null);
//000079:     }
//000080: 
//000081:     void SomePrivateMethod(string x)
//000082:     {
//000083:         Console.WriteLine(x);
//000084:     }
//000085: 
//000086:     public void MethodWithTwoRefs(ref string first, ref string second)
//000087:     {
//000088:     }
//000089: 
//000090:     public void MethodWithTwoOuts(out string first, out string second)
//000091:     {
//000092:         first = null;
//000093:         second = null;
//000094:     }
//000095: 
//000096:     public void MethodWithOptionalParameter(string optional = null)
//000097:     {
//000098:     }
//000099: 
//000100:     public void MethodWithOptionalParameterWithNonNullDefaultValue(string optional = "default")
//000101:     {
//000102:     }
//000103: 
//000104:     public void MethodWithOptionalParameterWithNonNullDefaultValueButAllowNullAttribute([AllowNull] string optional = "default")
//000105:     {
//000106:     }
//000107: 
//000108:     public void MethodWithGenericOut<T>(out T item)
//000109:     {
//000110:         item = default;
//000111:     }
//000112: 
//000113:     public T MethodWithGenericReturn<T>(bool returnNull)
//000114:     {
//000115:         return returnNull ? default : Activator.CreateInstance<T>();
//000116:     }
//000117: 
//000118:     public object MethodWithOutAndReturn(out string prefix)
//000119:     {
//000120:         prefix = null;
//000121:         return null;
//000122:     }
//000123: 
//000124:     public void MethodWithExistingArgumentGuard(string x)
//000125:     {
//000126:         if (string.IsNullOrEmpty(x))
//000127:             throw new ArgumentException("x is null or empty.", "x");
//000128: 
//000129:         Console.WriteLine(x);
//000130:     }
//000131: 
//000132:     public void MethodWithExistingArgumentNullGuard(string x)
//000133:     {
//000134:         if (string.IsNullOrEmpty(x))
//000135:             throw new ArgumentNullException("x");
//000136: 
//000137:         Console.WriteLine(x);
//000138:     }
//000139: 
//000140:     public void MethodWithExistingArgumentNullGuardWithMessage(string x)
//000141:     {
//000142:         if (string.IsNullOrEmpty(x))
//000143:             throw new ArgumentNullException("x", "x is null or empty.");
//000144: 
//000145:         Console.WriteLine(x);
//000146:     }
//000147: 
//000148:     public string ReturnValueChecksWithBranchToRetInstruction()
//000149:     {
//000150:         // This is a regression test scenario for the "Branch to RET" issue described in https://github.com/Fody/NullGuard/issues/57.
//000151: 
//000152:         // It is important that the return value is assigned *before* the branch, otherwise the C# compiler emits
//000153:         // instructions before the RET instructions, which wouldn't trigger the original issue.
//000154:         string returnValue = null;
//000155: 
//000156:         // The following, not-reachable, branch will jump directly to the RET statement (at least with Roslyn 1.0 with
//000157:         // enabled optimizations flag) which triggers the issue (the return value checks will be skipped).
//000158:         if ("".Length == 42)
//000159:             throw new Exception("Not reachable");
//000160: 
//000161:         return returnValue;
//000162:     }
//000163: 
//000164:     public void OutValueChecksWithBranchToRetInstruction(out string outParam)
//000165:     {
//000166:         // This is the same scenario as above, but for out parameters.
//000167: 
//000168:         outParam = null;
//000169: 
//000170:         if ("".Length == 42)
//000171:             throw new Exception("Not reachable");
//000172:     }
//000173: 
//000174:     public string GetterReturnValueChecksWithBranchToRetInstruction
//000175:     {
//000176:         get
//000177:         {
//000178:             // This is the same scenario as above, but for property getters.
//000179: 
//000180:             string returnValue = null;
//000181: 
//000182:             if ("".Length == 42)
//000183:                 throw new Exception("Not reachable");
//000184: 
//000185:             return returnValue;
//000186:         }
//000187:     }
//000188: 
//000189:     public void OutValueChecksWithRetInstructionAsSwitchCase(int i, out string outParam)
//000190:     {
//000191:         // This is the same scenario as above, but with a SWITCH instruction with branch targets to RET
//000192:         // instructions (they are handled specially).
//000193:         // Note that its important to have more than sections to prove that all sections with only a RET instruction are handled.
//000194: 
//000195:         outParam = null;
//000196:         switch (i)
//000197:         {
//000198:             case 0:
//000199:                 return;
//000200:             case 1:
//000201:                 Console.WriteLine("1");
//000202:                 break;
//000203:             case 2:
//000204:                 return;
//000205:             case 3:
//000206:                 Console.WriteLine("3");
//000207:                 break;
//000208:         }
//000209:     }
//000210: }
    IL_0006:  dup
    IL_0007:  brtrue.s   IL_0015
    IL_0009:  pop
    IL_000a:  ldstr      "[NullGuard] Return value of property 'System.Strin"
    + "g SimpleClass::PropertyAllowsNullSetButDoesNotAllowNullGet()' is null."
    IL_000f:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_0014:  throw
    IL_0015:  ret
  } 
  .method public hidebysig specialname instance void 
          set_PropertyAllowsNullSetButDoesNotAllowNullGet(string 'value') cil managed
  {
    // Code size       8 (0x8)
    .maxstack  2
//000033:     public string PropertyAllowsNullSetButDoesNotAllowNullGet { get; [param: AllowNull] set; }
    IL_0000:  ldarg.0
    IL_0001:  ldarg.1
    IL_0002:  stfld      string SimpleClass::'<PropertyAllowsNullSetButDoesNotAllowNullGet>k__BackingField'
    IL_0007:  ret
  } 
  .method public hidebysig specialname instance valuetype [mscorlib]System.Nullable`1<int32> 
          get_NonNullNullableProperty() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
//000034: 
//000035:     public int? NonNullNullableProperty { get; set; }
    IL_0000:  ldarg.0
    IL_0001:  ldfld      valuetype [mscorlib]System.Nullable`1<int32> SimpleClass::'<NonNullNullableProperty>k__BackingField'
    IL_0006:  ret
  } 
  .method public hidebysig specialname instance void 
          set_NonNullNullableProperty(valuetype [mscorlib]System.Nullable`1<int32> 'value') cil managed
  {
    // Code size       8 (0x8)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  ldarg.1
    IL_0002:  stfld      valuetype [mscorlib]System.Nullable`1<int32> SimpleClass::'<NonNullNullableProperty>k__BackingField'
    IL_0007:  ret
  } 
  .method public hidebysig instance string 
          MethodWithReturnValue(bool returnNull) cil managed
  {
    // Code size       41 (0x29)
    .maxstack  2
//000036: 
//000037:     public string MethodWithReturnValue(bool returnNull)
//000038:     {
//000039:         return returnNull ? null : "";
    IL_0000:  ldarg.1
    IL_0001:  brtrue.s   IL_0018
    IL_0003:  ldstr      ""
//000040:     }
//000041: 
//000042:     public void MethodWithRef(ref object returnNull)
//000043:     {
//000044:     }
//000045: 
//000046:     public void MethodWithGeneric<T>(T returnNull)
//000047:     {
//000048:     }
//000049: 
//000050:     public void MethodWithGenericRef<T>(ref T returnNull)
//000051:     {
//000052:     }
//000053: 
//000054:     [return: AllowNull]
//000055:     public string MethodAllowsNullReturnValue()
//000056:     {
//000057:         return null;
//000058:     }
//000059: 
//000060:     [CanBeNull]
//000061:     public string MethodWithCanBeNullResult()
//000062:     {
//000063:         return null;
//000064:     }
//000065: 
//000066:     public void MethodWithOutValue(out string nonNullOutArg)
//000067:     {
//000068:         nonNullOutArg = null;
//000069:     }
//000070: 
//000071:     public void MethodWithAllowedNullOutValue([AllowNull]out string nonNullOutArg)
//000072:     {
//000073:         nonNullOutArg = null;
//000074:     }
//000075: 
//000076:     public void PublicWrapperOfPrivateMethod()
//000077:     {
//000078:         SomePrivateMethod(null);
//000079:     }
//000080: 
//000081:     void SomePrivateMethod(string x)
//000082:     {
//000083:         Console.WriteLine(x);
//000084:     }
//000085: 
//000086:     public void MethodWithTwoRefs(ref string first, ref string second)
//000087:     {
//000088:     }
//000089: 
//000090:     public void MethodWithTwoOuts(out string first, out string second)
//000091:     {
//000092:         first = null;
//000093:         second = null;
//000094:     }
//000095: 
//000096:     public void MethodWithOptionalParameter(string optional = null)
//000097:     {
//000098:     }
//000099: 
//000100:     public void MethodWithOptionalParameterWithNonNullDefaultValue(string optional = "default")
//000101:     {
//000102:     }
//000103: 
//000104:     public void MethodWithOptionalParameterWithNonNullDefaultValueButAllowNullAttribute([AllowNull] string optional = "default")
//000105:     {
//000106:     }
//000107: 
//000108:     public void MethodWithGenericOut<T>(out T item)
//000109:     {
//000110:         item = default;
//000111:     }
//000112: 
//000113:     public T MethodWithGenericReturn<T>(bool returnNull)
//000114:     {
//000115:         return returnNull ? default : Activator.CreateInstance<T>();
//000116:     }
//000117: 
//000118:     public object MethodWithOutAndReturn(out string prefix)
//000119:     {
//000120:         prefix = null;
//000121:         return null;
//000122:     }
//000123: 
//000124:     public void MethodWithExistingArgumentGuard(string x)
//000125:     {
//000126:         if (string.IsNullOrEmpty(x))
//000127:             throw new ArgumentException("x is null or empty.", "x");
//000128: 
//000129:         Console.WriteLine(x);
//000130:     }
//000131: 
//000132:     public void MethodWithExistingArgumentNullGuard(string x)
//000133:     {
//000134:         if (string.IsNullOrEmpty(x))
//000135:             throw new ArgumentNullException("x");
//000136: 
//000137:         Console.WriteLine(x);
//000138:     }
//000139: 
//000140:     public void MethodWithExistingArgumentNullGuardWithMessage(string x)
//000141:     {
//000142:         if (string.IsNullOrEmpty(x))
//000143:             throw new ArgumentNullException("x", "x is null or empty.");
//000144: 
//000145:         Console.WriteLine(x);
//000146:     }
//000147: 
//000148:     public string ReturnValueChecksWithBranchToRetInstruction()
//000149:     {
//000150:         // This is a regression test scenario for the "Branch to RET" issue described in https://github.com/Fody/NullGuard/issues/57.
//000151: 
//000152:         // It is important that the return value is assigned *before* the branch, otherwise the C# compiler emits
//000153:         // instructions before the RET instructions, which wouldn't trigger the original issue.
//000154:         string returnValue = null;
//000155: 
//000156:         // The following, not-reachable, branch will jump directly to the RET statement (at least with Roslyn 1.0 with
//000157:         // enabled optimizations flag) which triggers the issue (the return value checks will be skipped).
//000158:         if ("".Length == 42)
//000159:             throw new Exception("Not reachable");
//000160: 
//000161:         return returnValue;
//000162:     }
//000163: 
//000164:     public void OutValueChecksWithBranchToRetInstruction(out string outParam)
//000165:     {
//000166:         // This is the same scenario as above, but for out parameters.
//000167: 
//000168:         outParam = null;
//000169: 
//000170:         if ("".Length == 42)
//000171:             throw new Exception("Not reachable");
//000172:     }
//000173: 
//000174:     public string GetterReturnValueChecksWithBranchToRetInstruction
//000175:     {
//000176:         get
//000177:         {
//000178:             // This is the same scenario as above, but for property getters.
//000179: 
//000180:             string returnValue = null;
//000181: 
//000182:             if ("".Length == 42)
//000183:                 throw new Exception("Not reachable");
//000184: 
//000185:             return returnValue;
//000186:         }
//000187:     }
//000188: 
//000189:     public void OutValueChecksWithRetInstructionAsSwitchCase(int i, out string outParam)
//000190:     {
//000191:         // This is the same scenario as above, but with a SWITCH instruction with branch targets to RET
//000192:         // instructions (they are handled specially).
//000193:         // Note that its important to have more than sections to prove that all sections with only a RET instruction are handled.
//000194: 
//000195:         outParam = null;
//000196:         switch (i)
//000197:         {
//000198:             case 0:
//000199:                 return;
//000200:             case 1:
//000201:                 Console.WriteLine("1");
//000202:                 break;
//000203:             case 2:
//000204:                 return;
//000205:             case 3:
//000206:                 Console.WriteLine("3");
//000207:                 break;
//000208:         }
//000209:     }
//000210: }
    IL_0008:  dup
    IL_0009:  brtrue.s   IL_0017
    IL_000b:  pop
    IL_000c:  ldstr      "[NullGuard] Return value of method 'System.String "
    + "SimpleClass::MethodWithReturnValue(System.Boolean)' is null."
    IL_0011:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_0016:  throw
    IL_0017:  ret
    IL_0018:  ldnull
    IL_0019:  dup
    IL_001a:  brtrue.s   IL_0028
    IL_001c:  pop
    IL_001d:  ldstr      "[NullGuard] Return value of method 'System.String "
    + "SimpleClass::MethodWithReturnValue(System.Boolean)' is null."
    IL_0022:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_0027:  throw
    IL_0028:  ret
  } 
  .method public hidebysig instance void 
          MethodWithRef(object& returnNull) cil managed
  {
    // Code size       21 (0x15)
    .maxstack  2
    IL_0000:  ldarg.1
    IL_0001:  ldind.ref
    IL_0002:  brtrue.s   IL_0014
    IL_0004:  ldstr      "returnNull"
    IL_0009:  ldstr      "[NullGuard] returnNull is null."
    IL_000e:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string,
                                                                                     string)
    IL_0013:  throw
    IL_0014:  ret
  } 
  .method public hidebysig instance void 
          MethodWithGeneric<T>(!!T returnNull) cil managed
  {
    // Code size       25 (0x19)
    .maxstack  2
    IL_0000:  ldarg.1
    IL_0001:  box        !!T
    IL_0006:  brtrue.s   IL_0018
    IL_0008:  ldstr      "returnNull"
    IL_000d:  ldstr      "[NullGuard] returnNull is null."
    IL_0012:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string,
                                                                                     string)
    IL_0017:  throw
    IL_0018:  ret
  } 
  .method public hidebysig instance void 
          MethodWithGenericRef<T>(!!T& returnNull) cil managed
  {
    // Code size       30 (0x1e)
    .maxstack  2
    IL_0000:  ldarg.1
    IL_0001:  ldobj      !!T
    IL_0006:  box        !!T
    IL_000b:  brtrue.s   IL_001d
    IL_000d:  ldstr      "returnNull"
    IL_0012:  ldstr      "[NullGuard] returnNull is null."
    IL_0017:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string,
                                                                                     string)
    IL_001c:  throw
    IL_001d:  ret
  } 
  .method public hidebysig instance string 
          MethodAllowsNullReturnValue() cil managed
  {
    // Code size       2 (0x2)
    .maxstack  1
//000057:         return null;
    IL_0000:  ldnull
    IL_0001:  ret
  } 
  .method public hidebysig instance string 
          MethodWithCanBeNullResult() cil managed
  {
    .custom instance void CanBeNullAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       2 (0x2)
    .maxstack  1
//000058:     }
//000059: 
//000060:     [CanBeNull]
//000061:     public string MethodWithCanBeNullResult()
//000062:     {
//000063:         return null;
    IL_0000:  ldnull
    IL_0001:  ret
  } 
  .method public hidebysig instance void 
          MethodWithOutValue([out] string& nonNullOutArg) cil managed
  {
    // Code size       19 (0x13)
    .maxstack  2
//000064:     }
//000065: 
//000066:     public void MethodWithOutValue(out string nonNullOutArg)
//000067:     {
//000068:         nonNullOutArg = null;
    IL_0000:  ldarg.1
    IL_0001:  ldnull
    IL_0002:  stind.ref
//000069:     }
//000070: 
//000071:     public void MethodWithAllowedNullOutValue([AllowNull]out string nonNullOutArg)
//000072:     {
//000073:         nonNullOutArg = null;
//000074:     }
//000075: 
//000076:     public void PublicWrapperOfPrivateMethod()
//000077:     {
//000078:         SomePrivateMethod(null);
//000079:     }
//000080: 
//000081:     void SomePrivateMethod(string x)
//000082:     {
//000083:         Console.WriteLine(x);
//000084:     }
//000085: 
//000086:     public void MethodWithTwoRefs(ref string first, ref string second)
//000087:     {
//000088:     }
//000089: 
//000090:     public void MethodWithTwoOuts(out string first, out string second)
//000091:     {
//000092:         first = null;
//000093:         second = null;
//000094:     }
//000095: 
//000096:     public void MethodWithOptionalParameter(string optional = null)
//000097:     {
//000098:     }
//000099: 
//000100:     public void MethodWithOptionalParameterWithNonNullDefaultValue(string optional = "default")
//000101:     {
//000102:     }
//000103: 
//000104:     public void MethodWithOptionalParameterWithNonNullDefaultValueButAllowNullAttribute([AllowNull] string optional = "default")
//000105:     {
//000106:     }
//000107: 
//000108:     public void MethodWithGenericOut<T>(out T item)
//000109:     {
//000110:         item = default;
//000111:     }
//000112: 
//000113:     public T MethodWithGenericReturn<T>(bool returnNull)
//000114:     {
//000115:         return returnNull ? default : Activator.CreateInstance<T>();
//000116:     }
//000117: 
//000118:     public object MethodWithOutAndReturn(out string prefix)
//000119:     {
//000120:         prefix = null;
//000121:         return null;
//000122:     }
//000123: 
//000124:     public void MethodWithExistingArgumentGuard(string x)
//000125:     {
//000126:         if (string.IsNullOrEmpty(x))
//000127:             throw new ArgumentException("x is null or empty.", "x");
//000128: 
//000129:         Console.WriteLine(x);
//000130:     }
//000131: 
//000132:     public void MethodWithExistingArgumentNullGuard(string x)
//000133:     {
//000134:         if (string.IsNullOrEmpty(x))
//000135:             throw new ArgumentNullException("x");
//000136: 
//000137:         Console.WriteLine(x);
//000138:     }
//000139: 
//000140:     public void MethodWithExistingArgumentNullGuardWithMessage(string x)
//000141:     {
//000142:         if (string.IsNullOrEmpty(x))
//000143:             throw new ArgumentNullException("x", "x is null or empty.");
//000144: 
//000145:         Console.WriteLine(x);
//000146:     }
//000147: 
//000148:     public string ReturnValueChecksWithBranchToRetInstruction()
//000149:     {
//000150:         // This is a regression test scenario for the "Branch to RET" issue described in https://github.com/Fody/NullGuard/issues/57.
//000151: 
//000152:         // It is important that the return value is assigned *before* the branch, otherwise the C# compiler emits
//000153:         // instructions before the RET instructions, which wouldn't trigger the original issue.
//000154:         string returnValue = null;
//000155: 
//000156:         // The following, not-reachable, branch will jump directly to the RET statement (at least with Roslyn 1.0 with
//000157:         // enabled optimizations flag) which triggers the issue (the return value checks will be skipped).
//000158:         if ("".Length == 42)
//000159:             throw new Exception("Not reachable");
//000160: 
//000161:         return returnValue;
//000162:     }
//000163: 
//000164:     public void OutValueChecksWithBranchToRetInstruction(out string outParam)
//000165:     {
//000166:         // This is the same scenario as above, but for out parameters.
//000167: 
//000168:         outParam = null;
//000169: 
//000170:         if ("".Length == 42)
//000171:             throw new Exception("Not reachable");
//000172:     }
//000173: 
//000174:     public string GetterReturnValueChecksWithBranchToRetInstruction
//000175:     {
//000176:         get
//000177:         {
//000178:             // This is the same scenario as above, but for property getters.
//000179: 
//000180:             string returnValue = null;
//000181: 
//000182:             if ("".Length == 42)
//000183:                 throw new Exception("Not reachable");
//000184: 
//000185:             return returnValue;
//000186:         }
//000187:     }
//000188: 
//000189:     public void OutValueChecksWithRetInstructionAsSwitchCase(int i, out string outParam)
//000190:     {
//000191:         // This is the same scenario as above, but with a SWITCH instruction with branch targets to RET
//000192:         // instructions (they are handled specially).
//000193:         // Note that its important to have more than sections to prove that all sections with only a RET instruction are handled.
//000194: 
//000195:         outParam = null;
//000196:         switch (i)
//000197:         {
//000198:             case 0:
//000199:                 return;
//000200:             case 1:
//000201:                 Console.WriteLine("1");
//000202:                 break;
//000203:             case 2:
//000204:                 return;
//000205:             case 3:
//000206:                 Console.WriteLine("3");
//000207:                 break;
//000208:         }
//000209:     }
//000210: }
    IL_0003:  ldarg.1
    IL_0004:  ldind.ref
    IL_0005:  brtrue.s   IL_0012
    IL_0007:  ldstr      "[NullGuard] Out parameter 'nonNullOutArg' is null."
    IL_000c:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_0011:  throw
    IL_0012:  ret
  } 
  .method public hidebysig instance void 
          MethodWithAllowedNullOutValue([out] string& nonNullOutArg) cil managed
  {
    // Code size       4 (0x4)
    .maxstack  2
//000073:         nonNullOutArg = null;
    IL_0000:  ldarg.1
    IL_0001:  ldnull
    IL_0002:  stind.ref
    IL_0003:  ret
  } 
  .method public hidebysig instance void 
          PublicWrapperOfPrivateMethod() cil managed
  {
    // Code size       8 (0x8)
    .maxstack  2
//000074:     }
//000075: 
//000076:     public void PublicWrapperOfPrivateMethod()
//000077:     {
//000078:         SomePrivateMethod(null);
    IL_0000:  ldarg.0
    IL_0001:  ldnull
    IL_0002:  call       instance void SimpleClass::SomePrivateMethod(string)
    IL_0007:  ret
  } 
  .method private hidebysig instance void 
          SomePrivateMethod(string x) cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
//000079:     }
//000080: 
//000081:     void SomePrivateMethod(string x)
//000082:     {
//000083:         Console.WriteLine(x);
    IL_0000:  ldarg.1
    IL_0001:  call       void [mscorlib]System.Console::WriteLine(string)
//000084:     }
    IL_0006:  ret
  } 
  .method public hidebysig instance void 
          MethodWithTwoRefs(string& first,
                            string& second) cil managed
  {
    // Code size       41 (0x29)
    .maxstack  2
//000085: 
//000086:     public void MethodWithTwoRefs(ref string first, ref string second)
//000087:     {
//000088:     }
//000089: 
//000090:     public void MethodWithTwoOuts(out string first, out string second)
//000091:     {
//000092:         first = null;
//000093:         second = null;
//000094:     }
//000095: 
//000096:     public void MethodWithOptionalParameter(string optional = null)
//000097:     {
//000098:     }
//000099: 
//000100:     public void MethodWithOptionalParameterWithNonNullDefaultValue(string optional = "default")
//000101:     {
//000102:     }
//000103: 
//000104:     public void MethodWithOptionalParameterWithNonNullDefaultValueButAllowNullAttribute([AllowNull] string optional = "default")
//000105:     {
//000106:     }
//000107: 
//000108:     public void MethodWithGenericOut<T>(out T item)
//000109:     {
//000110:         item = default;
//000111:     }
//000112: 
//000113:     public T MethodWithGenericReturn<T>(bool returnNull)
//000114:     {
//000115:         return returnNull ? default : Activator.CreateInstance<T>();
//000116:     }
//000117: 
//000118:     public object MethodWithOutAndReturn(out string prefix)
//000119:     {
//000120:         prefix = null;
//000121:         return null;
//000122:     }
//000123: 
//000124:     public void MethodWithExistingArgumentGuard(string x)
//000125:     {
//000126:         if (string.IsNullOrEmpty(x))
//000127:             throw new ArgumentException("x is null or empty.", "x");
//000128: 
//000129:         Console.WriteLine(x);
//000130:     }
//000131: 
//000132:     public void MethodWithExistingArgumentNullGuard(string x)
//000133:     {
//000134:         if (string.IsNullOrEmpty(x))
//000135:             throw new ArgumentNullException("x");
//000136: 
//000137:         Console.WriteLine(x);
//000138:     }
//000139: 
//000140:     public void MethodWithExistingArgumentNullGuardWithMessage(string x)
//000141:     {
//000142:         if (string.IsNullOrEmpty(x))
//000143:             throw new ArgumentNullException("x", "x is null or empty.");
//000144: 
//000145:         Console.WriteLine(x);
//000146:     }
//000147: 
//000148:     public string ReturnValueChecksWithBranchToRetInstruction()
//000149:     {
//000150:         // This is a regression test scenario for the "Branch to RET" issue described in https://github.com/Fody/NullGuard/issues/57.
//000151: 
//000152:         // It is important that the return value is assigned *before* the branch, otherwise the C# compiler emits
//000153:         // instructions before the RET instructions, which wouldn't trigger the original issue.
//000154:         string returnValue = null;
//000155: 
//000156:         // The following, not-reachable, branch will jump directly to the RET statement (at least with Roslyn 1.0 with
//000157:         // enabled optimizations flag) which triggers the issue (the return value checks will be skipped).
//000158:         if ("".Length == 42)
//000159:             throw new Exception("Not reachable");
//000160: 
//000161:         return returnValue;
//000162:     }
//000163: 
//000164:     public void OutValueChecksWithBranchToRetInstruction(out string outParam)
//000165:     {
//000166:         // This is the same scenario as above, but for out parameters.
//000167: 
//000168:         outParam = null;
//000169: 
//000170:         if ("".Length == 42)
//000171:             throw new Exception("Not reachable");
//000172:     }
//000173: 
//000174:     public string GetterReturnValueChecksWithBranchToRetInstruction
//000175:     {
//000176:         get
//000177:         {
//000178:             // This is the same scenario as above, but for property getters.
//000179: 
//000180:             string returnValue = null;
//000181: 
//000182:             if ("".Length == 42)
//000183:                 throw new Exception("Not reachable");
//000184: 
//000185:             return returnValue;
//000186:         }
//000187:     }
//000188: 
//000189:     public void OutValueChecksWithRetInstructionAsSwitchCase(int i, out string outParam)
//000190:     {
//000191:         // This is the same scenario as above, but with a SWITCH instruction with branch targets to RET
//000192:         // instructions (they are handled specially).
//000193:         // Note that its important to have more than sections to prove that all sections with only a RET instruction are handled.
//000194: 
//000195:         outParam = null;
//000196:         switch (i)
//000197:         {
//000198:             case 0:
//000199:                 return;
//000200:             case 1:
//000201:                 Console.WriteLine("1");
//000202:                 break;
//000203:             case 2:
//000204:                 return;
//000205:             case 3:
//000206:                 Console.WriteLine("3");
//000207:                 break;
//000208:         }
//000209:     }
//000210: }
    IL_0000:  ldarg.1
    IL_0001:  ldind.ref
    IL_0002:  brtrue.s   IL_0014
    IL_0004:  ldstr      "first"
    IL_0009:  ldstr      "[NullGuard] first is null."
    IL_000e:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string,
                                                                                     string)
    IL_0013:  throw
    IL_0014:  ldarg.2
    IL_0015:  ldind.ref
    IL_0016:  brtrue.s   IL_0028
    IL_0018:  ldstr      "second"
    IL_001d:  ldstr      "[NullGuard] second is null."
    IL_0022:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string,
                                                                                     string)
    IL_0027:  throw
    IL_0028:  ret
  } 
  .method public hidebysig instance void 
          MethodWithTwoOuts([out] string& first,
                            [out] string& second) cil managed
  {
    // Code size       37 (0x25)
    .maxstack  2
//000092:         first = null;
    IL_0000:  ldarg.1
    IL_0001:  ldnull
    IL_0002:  stind.ref
//000093:         second = null;
    IL_0003:  ldarg.2
    IL_0004:  ldnull
    IL_0005:  stind.ref
//000094:     }
//000095: 
//000096:     public void MethodWithOptionalParameter(string optional = null)
//000097:     {
//000098:     }
//000099: 
//000100:     public void MethodWithOptionalParameterWithNonNullDefaultValue(string optional = "default")
//000101:     {
//000102:     }
//000103: 
//000104:     public void MethodWithOptionalParameterWithNonNullDefaultValueButAllowNullAttribute([AllowNull] string optional = "default")
//000105:     {
//000106:     }
//000107: 
//000108:     public void MethodWithGenericOut<T>(out T item)
//000109:     {
//000110:         item = default;
//000111:     }
//000112: 
//000113:     public T MethodWithGenericReturn<T>(bool returnNull)
//000114:     {
//000115:         return returnNull ? default : Activator.CreateInstance<T>();
//000116:     }
//000117: 
//000118:     public object MethodWithOutAndReturn(out string prefix)
//000119:     {
//000120:         prefix = null;
//000121:         return null;
//000122:     }
//000123: 
//000124:     public void MethodWithExistingArgumentGuard(string x)
//000125:     {
//000126:         if (string.IsNullOrEmpty(x))
//000127:             throw new ArgumentException("x is null or empty.", "x");
//000128: 
//000129:         Console.WriteLine(x);
//000130:     }
//000131: 
//000132:     public void MethodWithExistingArgumentNullGuard(string x)
//000133:     {
//000134:         if (string.IsNullOrEmpty(x))
//000135:             throw new ArgumentNullException("x");
//000136: 
//000137:         Console.WriteLine(x);
//000138:     }
//000139: 
//000140:     public void MethodWithExistingArgumentNullGuardWithMessage(string x)
//000141:     {
//000142:         if (string.IsNullOrEmpty(x))
//000143:             throw new ArgumentNullException("x", "x is null or empty.");
//000144: 
//000145:         Console.WriteLine(x);
//000146:     }
//000147: 
//000148:     public string ReturnValueChecksWithBranchToRetInstruction()
//000149:     {
//000150:         // This is a regression test scenario for the "Branch to RET" issue described in https://github.com/Fody/NullGuard/issues/57.
//000151: 
//000152:         // It is important that the return value is assigned *before* the branch, otherwise the C# compiler emits
//000153:         // instructions before the RET instructions, which wouldn't trigger the original issue.
//000154:         string returnValue = null;
//000155: 
//000156:         // The following, not-reachable, branch will jump directly to the RET statement (at least with Roslyn 1.0 with
//000157:         // enabled optimizations flag) which triggers the issue (the return value checks will be skipped).
//000158:         if ("".Length == 42)
//000159:             throw new Exception("Not reachable");
//000160: 
//000161:         return returnValue;
//000162:     }
//000163: 
//000164:     public void OutValueChecksWithBranchToRetInstruction(out string outParam)
//000165:     {
//000166:         // This is the same scenario as above, but for out parameters.
//000167: 
//000168:         outParam = null;
//000169: 
//000170:         if ("".Length == 42)
//000171:             throw new Exception("Not reachable");
//000172:     }
//000173: 
//000174:     public string GetterReturnValueChecksWithBranchToRetInstruction
//000175:     {
//000176:         get
//000177:         {
//000178:             // This is the same scenario as above, but for property getters.
//000179: 
//000180:             string returnValue = null;
//000181: 
//000182:             if ("".Length == 42)
//000183:                 throw new Exception("Not reachable");
//000184: 
//000185:             return returnValue;
//000186:         }
//000187:     }
//000188: 
//000189:     public void OutValueChecksWithRetInstructionAsSwitchCase(int i, out string outParam)
//000190:     {
//000191:         // This is the same scenario as above, but with a SWITCH instruction with branch targets to RET
//000192:         // instructions (they are handled specially).
//000193:         // Note that its important to have more than sections to prove that all sections with only a RET instruction are handled.
//000194: 
//000195:         outParam = null;
//000196:         switch (i)
//000197:         {
//000198:             case 0:
//000199:                 return;
//000200:             case 1:
//000201:                 Console.WriteLine("1");
//000202:                 break;
//000203:             case 2:
//000204:                 return;
//000205:             case 3:
//000206:                 Console.WriteLine("3");
//000207:                 break;
//000208:         }
//000209:     }
//000210: }
    IL_0006:  ldarg.1
    IL_0007:  ldind.ref
    IL_0008:  brtrue.s   IL_0015
    IL_000a:  ldstr      "[NullGuard] Out parameter 'first' is null."
    IL_000f:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_0014:  throw
    IL_0015:  ldarg.2
    IL_0016:  ldind.ref
    IL_0017:  brtrue.s   IL_0024
    IL_0019:  ldstr      "[NullGuard] Out parameter 'second' is null."
    IL_001e:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_0023:  throw
    IL_0024:  ret
  } 
  .method public hidebysig instance void 
          MethodWithOptionalParameter([opt] string optional) cil managed
  {
    .param [1] = nullref
    // Code size       1 (0x1)
    .maxstack  0
    IL_0000:  ret
  } 
  .method public hidebysig instance void 
          MethodWithOptionalParameterWithNonNullDefaultValue([opt] string optional) cil managed
  {
    .param [1] = "default"
    // Code size       20 (0x14)
    .maxstack  2
    IL_0000:  ldarg.1
    IL_0001:  brtrue.s   IL_0013
    IL_0003:  ldstr      "optional"
    IL_0008:  ldstr      "[NullGuard] optional is null."
    IL_000d:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string,
                                                                                     string)
    IL_0012:  throw
    IL_0013:  ret
  } 
  .method public hidebysig instance void 
          MethodWithOptionalParameterWithNonNullDefaultValueButAllowNullAttribute([opt] string optional) cil managed
  {
    .param [1] = "default"
    // Code size       1 (0x1)
    .maxstack  0
    IL_0000:  ret
  } 
  .method public hidebysig instance void 
          MethodWithGenericOut<T>([out] !!T& item) cil managed
  {
    // Code size       32 (0x20)
    .maxstack  1
    IL_0000:  ldarg.1
    IL_0001:  initobj    !!T
    IL_0007:  ldarg.1
    IL_0008:  ldobj      !!T
    IL_000d:  box        !!T
    IL_0012:  brtrue.s   IL_001f
    IL_0014:  ldstr      "[NullGuard] Out parameter 'item' is null."
    IL_0019:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_001e:  throw
    IL_001f:  ret
  } 
  .method public hidebysig instance !!T  MethodWithGenericReturn<T>(bool returnNull) cil managed
  {
    // Code size       59 (0x3b)
    .maxstack  2
    .locals init ([0] !!T __var_0)
//000115:         return returnNull ? default : Activator.CreateInstance<T>();
    IL_0000:  ldarg.1
    IL_0001:  brtrue.s   IL_001d
    IL_0003:  call       !!0 [mscorlib]System.Activator::CreateInstance<!!0>()
//000116:     }
//000117: 
//000118:     public object MethodWithOutAndReturn(out string prefix)
//000119:     {
//000120:         prefix = null;
//000121:         return null;
//000122:     }
//000123: 
//000124:     public void MethodWithExistingArgumentGuard(string x)
//000125:     {
//000126:         if (string.IsNullOrEmpty(x))
//000127:             throw new ArgumentException("x is null or empty.", "x");
//000128: 
//000129:         Console.WriteLine(x);
//000130:     }
//000131: 
//000132:     public void MethodWithExistingArgumentNullGuard(string x)
//000133:     {
//000134:         if (string.IsNullOrEmpty(x))
//000135:             throw new ArgumentNullException("x");
//000136: 
//000137:         Console.WriteLine(x);
//000138:     }
//000139: 
//000140:     public void MethodWithExistingArgumentNullGuardWithMessage(string x)
//000141:     {
//000142:         if (string.IsNullOrEmpty(x))
//000143:             throw new ArgumentNullException("x", "x is null or empty.");
//000144: 
//000145:         Console.WriteLine(x);
//000146:     }
//000147: 
//000148:     public string ReturnValueChecksWithBranchToRetInstruction()
//000149:     {
//000150:         // This is a regression test scenario for the "Branch to RET" issue described in https://github.com/Fody/NullGuard/issues/57.
//000151: 
//000152:         // It is important that the return value is assigned *before* the branch, otherwise the C# compiler emits
//000153:         // instructions before the RET instructions, which wouldn't trigger the original issue.
//000154:         string returnValue = null;
//000155: 
//000156:         // The following, not-reachable, branch will jump directly to the RET statement (at least with Roslyn 1.0 with
//000157:         // enabled optimizations flag) which triggers the issue (the return value checks will be skipped).
//000158:         if ("".Length == 42)
//000159:             throw new Exception("Not reachable");
//000160: 
//000161:         return returnValue;
//000162:     }
//000163: 
//000164:     public void OutValueChecksWithBranchToRetInstruction(out string outParam)
//000165:     {
//000166:         // This is the same scenario as above, but for out parameters.
//000167: 
//000168:         outParam = null;
//000169: 
//000170:         if ("".Length == 42)
//000171:             throw new Exception("Not reachable");
//000172:     }
//000173: 
//000174:     public string GetterReturnValueChecksWithBranchToRetInstruction
//000175:     {
//000176:         get
//000177:         {
//000178:             // This is the same scenario as above, but for property getters.
//000179: 
//000180:             string returnValue = null;
//000181: 
//000182:             if ("".Length == 42)
//000183:                 throw new Exception("Not reachable");
//000184: 
//000185:             return returnValue;
//000186:         }
//000187:     }
//000188: 
//000189:     public void OutValueChecksWithRetInstructionAsSwitchCase(int i, out string outParam)
//000190:     {
//000191:         // This is the same scenario as above, but with a SWITCH instruction with branch targets to RET
//000192:         // instructions (they are handled specially).
//000193:         // Note that its important to have more than sections to prove that all sections with only a RET instruction are handled.
//000194: 
//000195:         outParam = null;
//000196:         switch (i)
//000197:         {
//000198:             case 0:
//000199:                 return;
//000200:             case 1:
//000201:                 Console.WriteLine("1");
//000202:                 break;
//000203:             case 2:
//000204:                 return;
//000205:             case 3:
//000206:                 Console.WriteLine("3");
//000207:                 break;
//000208:         }
//000209:     }
//000210: }
    IL_0008:  dup
    IL_0009:  box        !!T
    IL_000e:  brtrue.s   IL_001c
    IL_0010:  pop
    IL_0011:  ldstr      "[NullGuard] Return value of method 'T SimpleClass:"
    + ":MethodWithGenericReturn(System.Boolean)' is null."
    IL_0016:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_001b:  throw
    IL_001c:  ret
    IL_001d:  ldloca.s   __var_0
    IL_001f:  initobj    !!T
    IL_0025:  ldloc.0
    IL_0026:  dup
    IL_0027:  box        !!T
    IL_002c:  brtrue.s   IL_003a
    IL_002e:  pop
    IL_002f:  ldstr      "[NullGuard] Return value of method 'T SimpleClass:"
    + ":MethodWithGenericReturn(System.Boolean)' is null."
    IL_0034:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_0039:  throw
    IL_003a:  ret
  } 
  .method public hidebysig instance object 
          MethodWithOutAndReturn([out] string& prefix) cil managed
  {
    // Code size       35 (0x23)
    .maxstack  2
//000120:         prefix = null;
    IL_0000:  ldarg.1
    IL_0001:  ldnull
    IL_0002:  stind.ref
//000121:         return null;
    IL_0003:  ldnull
//000122:     }
//000123: 
//000124:     public void MethodWithExistingArgumentGuard(string x)
//000125:     {
//000126:         if (string.IsNullOrEmpty(x))
//000127:             throw new ArgumentException("x is null or empty.", "x");
//000128: 
//000129:         Console.WriteLine(x);
//000130:     }
//000131: 
//000132:     public void MethodWithExistingArgumentNullGuard(string x)
//000133:     {
//000134:         if (string.IsNullOrEmpty(x))
//000135:             throw new ArgumentNullException("x");
//000136: 
//000137:         Console.WriteLine(x);
//000138:     }
//000139: 
//000140:     public void MethodWithExistingArgumentNullGuardWithMessage(string x)
//000141:     {
//000142:         if (string.IsNullOrEmpty(x))
//000143:             throw new ArgumentNullException("x", "x is null or empty.");
//000144: 
//000145:         Console.WriteLine(x);
//000146:     }
//000147: 
//000148:     public string ReturnValueChecksWithBranchToRetInstruction()
//000149:     {
//000150:         // This is a regression test scenario for the "Branch to RET" issue described in https://github.com/Fody/NullGuard/issues/57.
//000151: 
//000152:         // It is important that the return value is assigned *before* the branch, otherwise the C# compiler emits
//000153:         // instructions before the RET instructions, which wouldn't trigger the original issue.
//000154:         string returnValue = null;
//000155: 
//000156:         // The following, not-reachable, branch will jump directly to the RET statement (at least with Roslyn 1.0 with
//000157:         // enabled optimizations flag) which triggers the issue (the return value checks will be skipped).
//000158:         if ("".Length == 42)
//000159:             throw new Exception("Not reachable");
//000160: 
//000161:         return returnValue;
//000162:     }
//000163: 
//000164:     public void OutValueChecksWithBranchToRetInstruction(out string outParam)
//000165:     {
//000166:         // This is the same scenario as above, but for out parameters.
//000167: 
//000168:         outParam = null;
//000169: 
//000170:         if ("".Length == 42)
//000171:             throw new Exception("Not reachable");
//000172:     }
//000173: 
//000174:     public string GetterReturnValueChecksWithBranchToRetInstruction
//000175:     {
//000176:         get
//000177:         {
//000178:             // This is the same scenario as above, but for property getters.
//000179: 
//000180:             string returnValue = null;
//000181: 
//000182:             if ("".Length == 42)
//000183:                 throw new Exception("Not reachable");
//000184: 
//000185:             return returnValue;
//000186:         }
//000187:     }
//000188: 
//000189:     public void OutValueChecksWithRetInstructionAsSwitchCase(int i, out string outParam)
//000190:     {
//000191:         // This is the same scenario as above, but with a SWITCH instruction with branch targets to RET
//000192:         // instructions (they are handled specially).
//000193:         // Note that its important to have more than sections to prove that all sections with only a RET instruction are handled.
//000194: 
//000195:         outParam = null;
//000196:         switch (i)
//000197:         {
//000198:             case 0:
//000199:                 return;
//000200:             case 1:
//000201:                 Console.WriteLine("1");
//000202:                 break;
//000203:             case 2:
//000204:                 return;
//000205:             case 3:
//000206:                 Console.WriteLine("3");
//000207:                 break;
//000208:         }
//000209:     }
//000210: }
    IL_0004:  ldarg.1
    IL_0005:  ldind.ref
    IL_0006:  brtrue.s   IL_0013
    IL_0008:  ldstr      "[NullGuard] Out parameter 'prefix' is null."
    IL_000d:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_0012:  throw
    IL_0013:  dup
    IL_0014:  brtrue.s   IL_0022
    IL_0016:  pop
    IL_0017:  ldstr      "[NullGuard] Return value of method 'System.Object "
    + "SimpleClass::MethodWithOutAndReturn(System.String&)' is null."
    IL_001c:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_0021:  throw
    IL_0022:  ret
  } 
  .method public hidebysig instance void 
          MethodWithExistingArgumentGuard(string x) cil managed
  {
    // Code size       50 (0x32)
    .maxstack  2
    IL_0000:  ldarg.1
    IL_0001:  brtrue.s   IL_0013
    IL_0003:  ldstr      "x"
    IL_0008:  ldstr      "[NullGuard] x is null."
    IL_000d:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string,
                                                                                     string)
    IL_0012:  throw
//000126:         if (string.IsNullOrEmpty(x))
    IL_0013:  ldarg.1
    IL_0014:  call       bool [mscorlib]System.String::IsNullOrEmpty(string)
    IL_0019:  brfalse.s  IL_002b
//000127:             throw new ArgumentException("x is null or empty.", "x");
    IL_001b:  ldstr      "x is null or empty."
    IL_0020:  ldstr      "x"
    IL_0025:  newobj     instance void [mscorlib]System.ArgumentException::.ctor(string,
                                                                                 string)
    IL_002a:  throw
//000128: 
//000129:         Console.WriteLine(x);
    IL_002b:  ldarg.1
    IL_002c:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_0031:  ret
  } 
  .method public hidebysig instance void 
          MethodWithExistingArgumentNullGuard(string x) cil managed
  {
    // Code size       26 (0x1a)
    .maxstack  1
//000130:     }
//000131: 
//000132:     public void MethodWithExistingArgumentNullGuard(string x)
//000133:     {
//000134:         if (string.IsNullOrEmpty(x))
    IL_0000:  ldarg.1
    IL_0001:  call       bool [mscorlib]System.String::IsNullOrEmpty(string)
    IL_0006:  brfalse.s  IL_0013
//000135:             throw new ArgumentNullException("x");
    IL_0008:  ldstr      "x"
    IL_000d:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
    IL_0012:  throw
//000136: 
//000137:         Console.WriteLine(x);
    IL_0013:  ldarg.1
    IL_0014:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_0019:  ret
  } 
  .method public hidebysig instance void 
          MethodWithExistingArgumentNullGuardWithMessage(string x) cil managed
  {
    // Code size       31 (0x1f)
    .maxstack  2
//000138:     }
//000139: 
//000140:     public void MethodWithExistingArgumentNullGuardWithMessage(string x)
//000141:     {
//000142:         if (string.IsNullOrEmpty(x))
    IL_0000:  ldarg.1
    IL_0001:  call       bool [mscorlib]System.String::IsNullOrEmpty(string)
    IL_0006:  brfalse.s  IL_0018
//000143:             throw new ArgumentNullException("x", "x is null or empty.");
    IL_0008:  ldstr      "x"
    IL_000d:  ldstr      "x is null or empty."
    IL_0012:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string,
                                                                                     string)
    IL_0017:  throw
//000144: 
//000145:         Console.WriteLine(x);
    IL_0018:  ldarg.1
    IL_0019:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_001e:  ret
  } 
  .method public hidebysig instance string 
          ReturnValueChecksWithBranchToRetInstruction() cil managed
  {
    // Code size       44 (0x2c)
    .maxstack  2
    .locals init ([0] string returnValue)
//000146:     }
//000147: 
//000148:     public string ReturnValueChecksWithBranchToRetInstruction()
//000149:     {
//000150:         // This is a regression test scenario for the "Branch to RET" issue described in https://github.com/Fody/NullGuard/issues/57.
//000151: 
//000152:         // It is important that the return value is assigned *before* the branch, otherwise the C# compiler emits
//000153:         // instructions before the RET instructions, which wouldn't trigger the original issue.
//000154:         string returnValue = null;
    IL_0000:  ldnull
    IL_0001:  stloc.0
//000155: 
//000156:         // The following, not-reachable, branch will jump directly to the RET statement (at least with Roslyn 1.0 with
//000157:         // enabled optimizations flag) which triggers the issue (the return value checks will be skipped).
//000158:         if ("".Length == 42)
    IL_0002:  ldstr      ""
    IL_0007:  call       instance int32 [mscorlib]System.String::get_Length()
    IL_000c:  ldc.i4.s   42
    IL_000e:  bne.un.s   IL_001b
//000159:             throw new Exception("Not reachable");
    IL_0010:  ldstr      "Not reachable"
    IL_0015:  newobj     instance void [mscorlib]System.Exception::.ctor(string)
    IL_001a:  throw
//000160: 
//000161:         return returnValue;
    IL_001b:  ldloc.0
//000162:     }
//000163: 
//000164:     public void OutValueChecksWithBranchToRetInstruction(out string outParam)
//000165:     {
//000166:         // This is the same scenario as above, but for out parameters.
//000167: 
//000168:         outParam = null;
//000169: 
//000170:         if ("".Length == 42)
//000171:             throw new Exception("Not reachable");
//000172:     }
//000173: 
//000174:     public string GetterReturnValueChecksWithBranchToRetInstruction
//000175:     {
//000176:         get
//000177:         {
//000178:             // This is the same scenario as above, but for property getters.
//000179: 
//000180:             string returnValue = null;
//000181: 
//000182:             if ("".Length == 42)
//000183:                 throw new Exception("Not reachable");
//000184: 
//000185:             return returnValue;
//000186:         }
//000187:     }
//000188: 
//000189:     public void OutValueChecksWithRetInstructionAsSwitchCase(int i, out string outParam)
//000190:     {
//000191:         // This is the same scenario as above, but with a SWITCH instruction with branch targets to RET
//000192:         // instructions (they are handled specially).
//000193:         // Note that its important to have more than sections to prove that all sections with only a RET instruction are handled.
//000194: 
//000195:         outParam = null;
//000196:         switch (i)
//000197:         {
//000198:             case 0:
//000199:                 return;
//000200:             case 1:
//000201:                 Console.WriteLine("1");
//000202:                 break;
//000203:             case 2:
//000204:                 return;
//000205:             case 3:
//000206:                 Console.WriteLine("3");
//000207:                 break;
//000208:         }
//000209:     }
//000210: }
    IL_001c:  dup
    IL_001d:  brtrue.s   IL_002b
    IL_001f:  pop
    IL_0020:  ldstr      "[NullGuard] Return value of method 'System.String "
    + "SimpleClass::ReturnValueChecksWithBranchToRetInstruction()' is null."
    IL_0025:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_002a:  throw
    IL_002b:  ret
  } 
  .method public hidebysig instance void 
          OutValueChecksWithBranchToRetInstruction([out] string& outParam) cil managed
  {
    // Code size       44 (0x2c)
    .maxstack  2
//000168:         outParam = null;
    IL_0000:  ldarg.1
    IL_0001:  ldnull
    IL_0002:  stind.ref
//000169: 
//000170:         if ("".Length == 42)
    IL_0003:  ldstr      ""
    IL_0008:  call       instance int32 [mscorlib]System.String::get_Length()
    IL_000d:  ldc.i4.s   42
    IL_000f:  bne.un.s   IL_001c
//000171:             throw new Exception("Not reachable");
    IL_0011:  ldstr      "Not reachable"
    IL_0016:  newobj     instance void [mscorlib]System.Exception::.ctor(string)
    IL_001b:  throw
//000172:     }
//000173: 
//000174:     public string GetterReturnValueChecksWithBranchToRetInstruction
//000175:     {
//000176:         get
//000177:         {
//000178:             // This is the same scenario as above, but for property getters.
//000179: 
//000180:             string returnValue = null;
//000181: 
//000182:             if ("".Length == 42)
//000183:                 throw new Exception("Not reachable");
//000184: 
//000185:             return returnValue;
//000186:         }
//000187:     }
//000188: 
//000189:     public void OutValueChecksWithRetInstructionAsSwitchCase(int i, out string outParam)
//000190:     {
//000191:         // This is the same scenario as above, but with a SWITCH instruction with branch targets to RET
//000192:         // instructions (they are handled specially).
//000193:         // Note that its important to have more than sections to prove that all sections with only a RET instruction are handled.
//000194: 
//000195:         outParam = null;
//000196:         switch (i)
//000197:         {
//000198:             case 0:
//000199:                 return;
//000200:             case 1:
//000201:                 Console.WriteLine("1");
//000202:                 break;
//000203:             case 2:
//000204:                 return;
//000205:             case 3:
//000206:                 Console.WriteLine("3");
//000207:                 break;
//000208:         }
//000209:     }
//000210: }
    IL_001c:  ldarg.1
    IL_001d:  ldind.ref
    IL_001e:  brtrue.s   IL_002b
    IL_0020:  ldstr      "[NullGuard] Out parameter 'outParam' is null."
    IL_0025:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_002a:  throw
    IL_002b:  ret
  } 
  .method public hidebysig specialname instance string 
          get_GetterReturnValueChecksWithBranchToRetInstruction() cil managed
  {
    // Code size       44 (0x2c)
    .maxstack  2
    .locals init ([0] string returnValue)
//000180:             string returnValue = null;
    IL_0000:  ldnull
    IL_0001:  stloc.0
//000181: 
//000182:             if ("".Length == 42)
    IL_0002:  ldstr      ""
    IL_0007:  call       instance int32 [mscorlib]System.String::get_Length()
    IL_000c:  ldc.i4.s   42
    IL_000e:  bne.un.s   IL_001b
//000183:                 throw new Exception("Not reachable");
    IL_0010:  ldstr      "Not reachable"
    IL_0015:  newobj     instance void [mscorlib]System.Exception::.ctor(string)
    IL_001a:  throw
//000184: 
//000185:             return returnValue;
    IL_001b:  ldloc.0
//000186:         }
//000187:     }
//000188: 
//000189:     public void OutValueChecksWithRetInstructionAsSwitchCase(int i, out string outParam)
//000190:     {
//000191:         // This is the same scenario as above, but with a SWITCH instruction with branch targets to RET
//000192:         // instructions (they are handled specially).
//000193:         // Note that its important to have more than sections to prove that all sections with only a RET instruction are handled.
//000194: 
//000195:         outParam = null;
//000196:         switch (i)
//000197:         {
//000198:             case 0:
//000199:                 return;
//000200:             case 1:
//000201:                 Console.WriteLine("1");
//000202:                 break;
//000203:             case 2:
//000204:                 return;
//000205:             case 3:
//000206:                 Console.WriteLine("3");
//000207:                 break;
//000208:         }
//000209:     }
//000210: }
    IL_001c:  dup
    IL_001d:  brtrue.s   IL_002b
    IL_001f:  pop
    IL_0020:  ldstr      "[NullGuard] Return value of property 'System.Strin"
    + "g SimpleClass::GetterReturnValueChecksWithBranchToRetInstruction()' is "
    + "null."
    IL_0025:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_002a:  throw
    IL_002b:  ret
  } 
  .method public hidebysig instance void 
          OutValueChecksWithRetInstructionAsSwitchCase(int32 i,
                                                       [out] string& outParam) cil managed
  {
    // Code size       125 (0x7d)
    .maxstack  2
//000195:         outParam = null;
    IL_0000:  ldarg.2
    IL_0001:  ldnull
    IL_0002:  stind.ref
//000196:         switch (i)
    IL_0003:  ldarg.1
    IL_0004:  switch     ( 
                          IL_0029,
                          IL_0039,
                          IL_0053,
                          IL_0063)
//000197:         {
//000198:             case 0:
//000199:                 return;
//000200:             case 1:
//000201:                 Console.WriteLine("1");
//000202:                 break;
//000203:             case 2:
//000204:                 return;
//000205:             case 3:
//000206:                 Console.WriteLine("3");
//000207:                 break;
//000208:         }
//000209:     }
//000210: }
    IL_0019:  ldarg.2
    IL_001a:  ldind.ref
    IL_001b:  brtrue.s   IL_0028
    IL_001d:  ldstr      "[NullGuard] Out parameter 'outParam' is null."
    IL_0022:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_0027:  throw
    IL_0028:  ret
    IL_0029:  ldarg.2
    IL_002a:  ldind.ref
    IL_002b:  brtrue.s   IL_0038
    IL_002d:  ldstr      "[NullGuard] Out parameter 'outParam' is null."
    IL_0032:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_0037:  throw
//000199:                 return;
    IL_0038:  ret
//000200:             case 1:
//000201:                 Console.WriteLine("1");
    IL_0039:  ldstr      "1"
    IL_003e:  call       void [mscorlib]System.Console::WriteLine(string)
//000202:                 break;
//000203:             case 2:
//000204:                 return;
//000205:             case 3:
//000206:                 Console.WriteLine("3");
//000207:                 break;
//000208:         }
//000209:     }
//000210: }
    IL_0043:  ldarg.2
    IL_0044:  ldind.ref
    IL_0045:  brtrue.s   IL_0052
    IL_0047:  ldstr      "[NullGuard] Out parameter 'outParam' is null."
    IL_004c:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_0051:  throw
//000202:                 break;
    IL_0052:  ret
//000203:             case 2:
//000204:                 return;
//000205:             case 3:
//000206:                 Console.WriteLine("3");
//000207:                 break;
//000208:         }
//000209:     }
//000210: }
    IL_0053:  ldarg.2
    IL_0054:  ldind.ref
    IL_0055:  brtrue.s   IL_0062
    IL_0057:  ldstr      "[NullGuard] Out parameter 'outParam' is null."
    IL_005c:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_0061:  throw
//000204:                 return;
    IL_0062:  ret
//000205:             case 3:
//000206:                 Console.WriteLine("3");
    IL_0063:  ldstr      "3"
    IL_0068:  call       void [mscorlib]System.Console::WriteLine(string)
//000207:                 break;
//000208:         }
//000209:     }
//000210: }
    IL_006d:  ldarg.2
    IL_006e:  ldind.ref
    IL_006f:  brtrue.s   IL_007c
    IL_0071:  ldstr      "[NullGuard] Out parameter 'outParam' is null."
    IL_0076:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_007b:  throw
    IL_007c:  ret
  } 
  .property instance string NonNullProperty()
  {
  } 
  .property instance string NullProperty()
  {
  } 
  .property instance string PropertyAllowsNullGetButDoesNotAllowNullSet()
  {
  } 
  .property instance string PropertyAllowsNullSetButDoesNotAllowNullGet()
  {
  } 
  .property instance valuetype [mscorlib]System.Nullable`1<int32>
          NonNullNullableProperty()
  {
  } 
  .property instance string GetterReturnValueChecksWithBranchToRetInstruction()
  {
  } 
}
